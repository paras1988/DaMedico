DataStructure: List , Tree , Map, Hashmap, Array
Ways

Backtracking:
  choose
  Explore
  Unchoose

Few Questions:
    Window sliding technique


DynamicPrgramming:

If we have processed this function before, return the result from the last time.

Otherwise calculate the result and remember it.


1. Think of a recursive approach to solving the problem.
    Essentially expressing the problem P(X) in terms of P(Y) or an expression involving P(Yi)
            where Yi is less than X.
    The "less than" here could mean multiple things. if X is an integer, then it could mean less than arithmetically.
    If X is a string, it could mean a substring of X.
    If X is an array, it could mean a subarray of X, and so forth.

2. Write a recursive code for the approach you just thought of.
            Lets say your function definition looks like this :
                    solve(A1, A2, A3 ... )

3. Save the results you get for every function run so that if solve(A1, A2, A3, ... ) is called again, you do not recompute the whole thing.

4. Analyze the space and time requirements, and improve it if possible.

    And voila, we have a DP solution ready.


Tree Problems:

Most of the binary tree problems can be solved in four steps(Split and Combine):
1. Work on the current(root) node, also called as base case.
2. Process the left sub-tree recursively.
3. Process the right sub-tree recursively.
4. Combine/Merge/choose the results from left sub-tree and right sub-tree


Array:

RainWater Taping Problems-- take min/max from left , min/max from right ,
    take min/max operate .. e.g. maxUnsortArray.

    Think if array is sorted then what to do, try to reach to that stage. example MaxDistance in bucketing


Same array operation no mem- 1 to N ... go to the index the number is , do manipulate(like
change to -1 , swap )

Think of tradeoff situations

Break problem into possibilities like overlap and non-overlap

In Arrangements like reverse swap for K break the array.

Try to get see pattern with less swaps needing.

Also check when said Integer it can be negative , zeroes.

Check edge cases when numbers : duplicates, negatives , zeroes


consider duplicates.
Consider negatives.
consider array index out of bound
consider 0 -1 in inputs.

STRING:

KMP  -> LPS (longest proper prefix which is also suffix)
edge cases: spaces side and between, not numeric, overflows in int, positives or negatives.


Bit manipulation:
XOR , numbers near to each other give lowest XOR


